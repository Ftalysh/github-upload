import numpy as np
from scipy import optimize


def solving_1():
    # Задаем коэффициенты целевой функции
    c = np.array([3, -3, -1, 1, 0])
    # Так как метод linprog решает задачу минимизации, поменяем знак коэффициентов целевой функции
    c = c * (-1)
    # Не забываем про значение свободного члена целевой функции
    ch = 14
    # Так же меняем знак свободного члена
    ch = ch * (-1)
    # Задаем матрицу левых частей ограничений равенства
    a_eq = np.array([[-2, 1, 1, 0, 0],
                     [4, 3, 0, -1, 0],
                     [8, -1, 0, 0, 1]])
    # Задаем вектор правх частей ограничений равенства
    b_eq = [2, 16, 16]
    # Оптимизируем целевую функцию min(Z)
    opt = optimize.linprog(c, A_eq=a_eq, b_eq=b_eq, bounds=None, method='interior-point')
    # Рассчитаем минимум функции, округленный до сотых
    min_z = round((opt.fun + ch), 2)
    # Так как мы решили задачу минимума, необходимо сменить знак для получения максимума
    max_z = min_z * (-1)
    # Выведем ответ на экран
    print('Ответ на задачу 1 пункт 1: max(z) = {};'.format(max_z))


def solving_2():
    # Задаем коэффициенты целевой функции
    c = np.array([1, 1, 1, 1])
    # Так как метод linprog решает задачу минимизации, поменяем знак коэффициентов целевой функции
    c = c * (-1)
    # Задаем матрицу левых частей ограничений равенства
    a_eq = np.array([[1, 3, 7, -1],
                     [1, -1, -1, 3]])
    # Задаем вектор правх частей ограничений равенства
    b_eq = [6, 2]
    # Оптимизируем целевую функцию min(Z)
    opt = optimize.linprog(c, A_eq=a_eq, b_eq=b_eq, bounds=None, method='interior-point')
    # Рассчитаем минимум функции, округленный до сотых
    min_z = round(opt.fun, 2)
    # Так как мы решили задачу минимума, необходимо сменить знак для получения максимума
    max_z = min_z * (-1)
    print('Ответ на задачу 1 пункт 2: max(z) = {};'.format(max_z))


def solving_3():
    # Задаем коэффициенты целевой функции
    c = [1, 3]
    # Задаем матрицу левых частей ограничений неравенства
    a_ub = np.array([[2, -1],
                     [2, 1],
                     [1, -1]])
    # Знак второго неравенства необходимо привести к виду '<=' -> необходимо домножить неравенство на (-1)
    a_ub = a_ub * [[1],
                   [-1],
                   [1]]
    # Задаем вектор правх частей ограничений неравенства
    b_ub = np.array([2, 4, -1])
    # Домножим второй элемент на (-1)
    b_ub = b_ub * [1, -1, 1]
    # Оптимизируем целевую функцию min(Z)
    opt = optimize.linprog(c, A_ub=a_ub, b_ub=b_ub, bounds=None, method='interior-point')
    # Рассчитаем минимум функции, округленный до сотых
    min_z = round(opt.fun, 2)
    # Выведем ответ на экран
    print('Ответ на задачу 1 пункт 3: min(z) = {};'.format(min_z))


def solving_4():
    # Задаем коэффициенты целевой функции
    c = np.array([1, 6, 3, 0, 4])
    # Так как метод linprog решает задачу минимизации, поменяем знак коэффициентов целевой функции
    c = c * (-1)
    # Не забываем про значение свободного члена целевой функции
    ch = -8
    # Так же меняем знак свободного члена
    ch = ch * (-1)
    # Задаем матрицу левых частей ограничений равенства
    a_eq = np.array([[1, 2, 0, -1, 3],
                     [0, 1, 1, 2, -1]])
    # Задаем вектор правх частей ограничений равенства
    b_eq = [12, 1]
    # Оптимизируем целевую функцию
    opt = optimize.linprog(c, A_eq=a_eq, b_eq=b_eq, bounds=None, method='interior-point')
    # Рассчитаем минимум функции, округленный до сотых
    min_z = round((opt.fun + ch), 2)
    # Так как мы решили задачу минимума, необходимо сменить знак для получения максимума
    max_z = min_z * (-1)
    # Выведем ответ на экран
    print('Ответ на задачу 1 пункт 4: max(z) = {}.'.format(max_z))


def generate_output():
    print('Вариант №7. Задание 1: \n')
    solving_1()
    solving_2()
    solving_3()
    solving_4()


generate_output()
